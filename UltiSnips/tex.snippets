global !p
texMathZones = ['texMathZone' + x for x in ['A', 'AS', 'B', 'BS', 'C',
'CS', 'D', 'DS', 'E', 'ES', 'F', 'FS', 'G', 'GS', 'H', 'HS', 'I', 'IS',
'J', 'JS', 'K', 'KS', 'L', 'LS', 'DS', 'V', 'W', 'X', 'Y', 'Z']]

texIgnoreMathZones = ['texMathText']

texMathZoneIds = vim.eval('map('+str(texMathZones)+", 'hlID(v:val)')")
texIgnoreMathZoneIds = vim.eval('map('+str(texIgnoreMathZones)+", 'hlID(v:val)')")

ignore = texIgnoreMathZoneIds[0]

def math():
    synstackids = vim.eval("synstack(line('.'), col('.') - (col('.')>=2 ? 1 : 0))")
    try:
        first = next(
            i for i in reversed(synstackids)
            if i in texIgnoreMathZoneIds or i in texMathZoneIds
        )
        return first != ignore
    except StopIteration:
        return False
endglobal

snippet no "note" b
\documentclass[a4paper]{article}

\usepackage{ctex}
\usepackage{amsmath, amssymb}
\setCJKmainfont[BoldFont={Source Han Serif SC SemiBold},ItalicFont={Adobe Kaiti Std}]{Source Han Serif SC}
\setCJKsansfont[BoldFont={Source Han Sans SC},ItalicFont={Adobe Kaiti Std}]{Adobe Kaiti Std}
\usepackage{amsmath, amssymb}
\usepackage{geometry}
\geometry{
	left=2.6cm,
	right=2.6cm,
	top=3cm,
	bottom=2.5cm}
% 行距设置
\linespread{1.2}
\setlength{\parskip}{3mm}
\setlength{\parindent}{2em}

\begin{document}
	$0
\end{document}
endsnippet

snippet pa "usepackage" b
\\usepackage{$0}
endsnippet

snippet po "usepackage with option" bA
\\usepackage[$0]{$1}
endsnippet

snippet beg "begin{} / end{}" bA
\begin{$1}
	${2:${VISUAL}}
\end{$1}
endsnippet

snippet beo "begin{} / end{}" bA
\begin{$1}{$2}
	${3:${VISUAL}}
\end{$1}
endsnippet

snippet frame "frame" bA
\begin{frame}{$1}
	${2:${VISUAL}}
\end{frame}
endsnippet


snippet /tt "ttfamily" iA
\{\\ttfamily $1\}
endsnippet

snippet /bemi "minted" bA
\begin{minted}{$1}
	$2
\end{minted}
$0
endsnippet

snippet /mi "mint" iA
\mint{$1}{$2}
endsnippet

snippet /imi "mintinline" iA
\mintinline{$1}{$2}
endsnippet

# snippet al "beamer alert" i
# \alert{${1:${VISUAL}}}
# endsnippet

snippet ch "child"
child {node {$1}}$0
endsnippet




# 行内公式
snippet mk "Math" wA
$$1$
endsnippet

# 行间公式
snippet dm "Math" wA
\[
$1
\]
endsnippet

# 下标
context "math()"
snippet '([A-Za-z])(\d)' "auto subscript" wrA
`!p snip.rv = match.group(1)`_`!p snip.rv = match.group(2)`
endsnippet

context "math()"
snippet '([A-Za-z])_(\d\d)' "auto subscript2" wrA
`!p snip.rv = match.group(1)`_{`!p snip.rv = match.group(2)`}
endsnippet

context "math()"
snippet ds "subscript" iA
_{$1}$0
endsnippet

# 上标
context "math()"
snippet us "superscript" iA
^{$1}$0
endsnippet

# 分数
# //生成空的分数
context "math()"
snippet // "Fraction" iA
\\frac{$1}{$2}$0
endsnippet
# 自动生成分数
context "math()"
snippet '((\d+)|(\d*)(\\)?([A-Za-z]+)((\^|_)(\{\d+\}|\d))*)/' "Fraction" wrA
\\frac{`!p snip.rv = match.group(1)`}{$1}$0
endsnippet

# 括号生成分数
context "math()"
snippet '^.*\)/' "() Fraction" wrA
`!p
stripped = match.string[:-1]
depth = 0
i = len(stripped) - 1
while True:
    if stripped[i] == ')': depth += 1
    if stripped[i] == '(': depth -= 1
    if depth == 0: break;
    i -= 1
snip.rv = stripped[0:i] + "\\frac{" + stripped[i+1:-1] + "}"
`{$1}$0
endsnippet

